<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.10.0">Jekyll</generator><link href="https://huhumt.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://huhumt.github.io/" rel="alternate" type="text/html" /><updated>2025-08-15T06:11:01-05:00</updated><id>https://huhumt.github.io/feed.xml</id><subtitle>This is my own small site</subtitle><entry><title type="html">Uk Vegetables</title><link href="https://huhumt.github.io/life/UK-vegetables/" rel="alternate" type="text/html" title="Uk Vegetables" /><published>2025-04-30T00:00:00-05:00</published><updated>2025-04-30T00:00:00-05:00</updated><id>https://huhumt.github.io/life/UK-vegetables</id><content type="html" xml:base="https://huhumt.github.io/life/UK-vegetables/"><![CDATA[<h1 id="英國花園蔬菜-uk-vegetable-gardening">英國花園蔬菜 (UK vegetable gardening)</h1>

<h2 id="多年生蔬菜-perenninal-vegetables">多年生蔬菜 (perenninal vegetables)</h2>

<ul>
  <li>蘆筍 (Asparagus)</li>
  <li>洋姜 (Jerusalem artichoke)</li>
  <li>大黃 (Rhubarb)</li>
  <li>西洋菜 (Watercress)</li>
  <li>黃花菜 (Daylily)</li>
  <li>寶塔菜 (Chinese artichoke)</li>
  <li>藠頭 (Allium chinense)</li>
  <li>蘘荷（Zingiber mioga, also known as Japanese ginger)</li>
</ul>]]></content><author><name></name></author><category term="Life" /><category term="Life" /><category term="2025" /><summary type="html"><![CDATA[英國花園蔬菜 (UK vegetable gardening)]]></summary></entry><entry><title type="html">Write interrupt safe function</title><link href="https://huhumt.github.io/programming/interrupt-safe-function/" rel="alternate" type="text/html" title="Write interrupt safe function" /><published>2021-10-27T07:32:23-05:00</published><updated>2021-10-27T07:32:23-05:00</updated><id>https://huhumt.github.io/programming/interrupt-safe-function</id><content type="html" xml:base="https://huhumt.github.io/programming/interrupt-safe-function/"><![CDATA[<p>如何保证主函数被中断函数打断后正常运行？
先看如下的例子：</p>

<p>``` c code
static volatile uint8_t g_ucIntCnt = 0;</p>

<p>void RTC_ISR(void) interrupt 5
{
    g_ucIntCnt++;
}</p>

<table>
  <tbody>
    <tr>
      <td>void loop(void)</td>
      <td>void loop(void)</td>
    </tr>
    <tr>
      <td>{</td>
      <td>{</td>
    </tr>
    <tr>
      <td>while (1)</td>
      <td>while (1)</td>
    </tr>
    <tr>
      <td>{</td>
      <td>{</td>
    </tr>
    <tr>
      <td>do_something1();</td>
      <td>do_something1();</td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>if (g_ucIntCnt == 100)</td>
      <td>if (g_ucIntCnt &gt;= 100)</td>
    </tr>
    <tr>
      <td>{</td>
      <td>{</td>
    </tr>
    <tr>
      <td>do_something2();</td>
      <td>do_something2();</td>
    </tr>
    <tr>
      <td>}</td>
      <td>g_ucIntCnt = 0;</td>
    </tr>
    <tr>
      <td> </td>
      <td>}</td>
    </tr>
    <tr>
      <td>g_ucIntCnt = 0;</td>
      <td> </td>
    </tr>
    <tr>
      <td>do_something3();</td>
      <td>do_something3();</td>
    </tr>
    <tr>
      <td>}</td>
      <td>}</td>
    </tr>
    <tr>
      <td>}</td>
      <td>}</td>
    </tr>
  </tbody>
</table>

<p>void main(void)
{
    init();
    loop();
}</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
请思考一下，程序中的 do_something2 会按预期每隔 100 个 rtc 单位运行一次吗？&lt;br /&gt;
左边的代码中：&lt;br /&gt;
1. 由于 do_something1 的代码复杂度未知，很大概率无法撞上 g_ucIntCnt = 100 的条件；&lt;br /&gt;
2. 另一方面，如果 do_something1 很短，在主循环中，在 g_ucIntCnt 还很小时过早清 0，也会导致无法满足条件；&lt;br /&gt;
3. 即使刚好凑巧，可以运行到 do_something2，假如函数内部有用到 g_ucIntCnt 也会导致程序错误。&lt;br /&gt;

右边的代码中：&lt;br /&gt;
4. 如果 do_something1 过于复杂，导致运行完之后 g_ucIntCnt 已经溢出，也无法运行 do_something2；&lt;br /&gt;
5. 同样有左边代码 3 的问题。&lt;br /&gt;

``` c code
static volatile uint8_t g_ucIntCnt = 0;
static volatile uint8_t g_ucIntCntFlag = 0;

void RTC_ISR(void) interrupt 5
{
    g_ucIntCnt++;

    if (g_ucIntCnt == 100)
    {
        g_ucIntCntFlag = 1;
    }
}

void loop(void)
{
    while (1)
    {
        do_something1();

        if (g_ucIntCntFlag)
        {
            do_something2();
            g_ucIntCnt = 0;
            g_ucIntCntFlag = 0;
        }

        do_something3();
    }
}

void main(void)
{
    init();
    loop();
}
</code></pre></div></div>]]></content><author><name></name></author><category term="Programming" /><category term="Programming" /><category term="2021" /><summary type="html"><![CDATA[如何保证主函数被中断函数打断后正常运行？ 先看如下的例子： ``` c code static volatile uint8_t g_ucIntCnt = 0; void RTC_ISR(void) interrupt 5 { g_ucIntCnt++; } void loop(void) void loop(void) { { while (1) while (1) { { do_something1(); do_something1();     if (g_ucIntCnt == 100) if (g_ucIntCnt &gt;= 100) { { do_something2(); do_something2(); } g_ucIntCnt = 0;   } g_ucIntCnt = 0;   do_something3(); do_something3(); } } } } void main(void) { init(); loop(); } 请思考一下，程序中的 do_something2 会按预期每隔 100 个 rtc 单位运行一次吗？&lt;br /&gt; 左边的代码中：&lt;br /&gt; 1. 由于 do_something1 的代码复杂度未知，很大概率无法撞上 g_ucIntCnt = 100 的条件；&lt;br /&gt; 2. 另一方面，如果 do_something1 很短，在主循环中，在 g_ucIntCnt 还很小时过早清 0，也会导致无法满足条件；&lt;br /&gt; 3. 即使刚好凑巧，可以运行到 do_something2，假如函数内部有用到 g_ucIntCnt 也会导致程序错误。&lt;br /&gt; 右边的代码中：&lt;br /&gt; 4. 如果 do_something1 过于复杂，导致运行完之后 g_ucIntCnt 已经溢出，也无法运行 do_something2；&lt;br /&gt; 5. 同样有左边代码 3 的问题。&lt;br /&gt; ``` c code static volatile uint8_t g_ucIntCnt = 0; static volatile uint8_t g_ucIntCntFlag = 0; void RTC_ISR(void) interrupt 5 { g_ucIntCnt++; if (g_ucIntCnt == 100) { g_ucIntCntFlag = 1; } } void loop(void) { while (1) { do_something1(); if (g_ucIntCntFlag) { do_something2(); g_ucIntCnt = 0; g_ucIntCntFlag = 0; } do_something3(); } } void main(void) { init(); loop(); }]]></summary></entry><entry><title type="html">How to make a bread?</title><link href="https://huhumt.github.io/life/make-bread/" rel="alternate" type="text/html" title="How to make a bread?" /><published>2021-10-26T07:27:23-05:00</published><updated>2021-10-26T07:27:23-05:00</updated><id>https://huhumt.github.io/life/make-bread</id><content type="html" xml:base="https://huhumt.github.io/life/make-bread/"><![CDATA[<p>Few years ago, I watched a series of BBC documentary of
“<a href="https://www.imdb.com/title/tt2795962/">Paul Hollywood’s Bread</a>” and it impressed me much.</p>

<p>Today I try to make my own bread following the guidance of <a href="https://www.paulhollywood.com/post/apricot-couronne">apricot-couronne</a>.
To my surprise, it’s quite easy and tasty.</p>]]></content><author><name></name></author><category term="Life" /><category term="Life" /><category term="2021" /><summary type="html"><![CDATA[Few years ago, I watched a series of BBC documentary of “Paul Hollywood’s Bread” and it impressed me much.]]></summary></entry><entry><title type="html">Hello world</title><link href="https://huhumt.github.io/others/hello-world/" rel="alternate" type="text/html" title="Hello world" /><published>2021-10-26T03:27:13-05:00</published><updated>2021-10-26T03:27:13-05:00</updated><id>https://huhumt.github.io/others/hello-world</id><content type="html" xml:base="https://huhumt.github.io/others/hello-world/"><![CDATA[<p>As a software engineer, my first blog should start with a “Hello world” program.</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">def</span> <span class="nf">hello_world</span><span class="p">()</span>
  <span class="nb">puts</span> <span class="s2">"Hello world"</span>
<span class="k">end</span>
<span class="n">hello_world</span><span class="p">()</span>
<span class="c1">#=&gt; prints 'Hello world' to STDOUT.</span></code></pre></figure>

<p>Another good examples for “<a href="https://github.com/leachim6/hello-world">Hello world</a>”.</p>]]></content><author><name></name></author><category term="Others" /><category term="Others" /><category term="2021" /><summary type="html"><![CDATA[As a software engineer, my first blog should start with a “Hello world” program. def hello_world() puts "Hello world" end hello_world() #=&gt; prints 'Hello world' to STDOUT. Another good examples for “Hello world”.]]></summary></entry></feed>